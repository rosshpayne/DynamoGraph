package rdm

import (
	"bytes"
	"errors"
	"fmt"
	"sync"
	"time"

	blk "github.com/DynamoGraph/block"
	gerr "github.com/DynamoGraph/dygerror"

	"github.com/DynamoGraph/cache"
	"github.com/DynamoGraph/db"
	"github.com/DynamoGraph/ds"
	"github.com/DynamoGraph/event"
	"github.com/DynamoGraph/util"
)

func AttachNode(cUID, pUID util.UID, sortK string) []error { // pTy string) error { // TODO: do I need pTy (parent Ty). They can be derived from node data. Child not must attach to parent attribute of same type
	//
	// update data cache to reflect child node attached to parent. This involves
	// 1. append chid UID to the associated parent uid-predicate, parent e.g. sortk A#G#:S
	// 2. propagate child scalar data to associated uid-predicate (parent's 'G' type) G#:S#:A etc..
	//
	var errS []error

	var addErr = func(e ...error) []error {
		errS = append(errS, e...)
		return errS
	}

	type ovflTarget struct {
		tUID   util.UID
		itemId int
	}

	var (
		eID     util.UID
		pnd     *cache.NodeCache
		ctyName string
		ok      bool
		err     error
		wg      sync.WaitGroup
	)

	gc := cache.NewCache()
	//
	// log Event via defer
	//
	defer func() func() {
		t0 := time.Now()
		return func() {
			t1 := time.Now()
			if err != nil {
				db.LogEventFail(eID, t1.Sub(t0).String(), err) // TODO : this should also create a CW log event
			} else {
				db.LogEventSuccess(eID, t1.Sub(t0).String())
			}
		}
	}()()
	// create channels used to pass target UID for propagation and errors
	xch := make(chan ovflTarget)
	defer close(xch)
	errch := make(chan error, 1) // buffered so allowed to return
	defer close(errch)
	//
	// NOOP condition aka CEG - Concurrent event gatekeeper. Add edge only if it doesn't already exist (in one atomic unit) that can be used to protect against identical concurrent (or otherwise) attachnode events.
	//
	if ok, err := db.EdgeExists(cUID, pUID, sortK, db.ADD); ok {
		fmt.Println("Edge does exit: ", err.Error())
		if errors.Is(err, db.ErrConditionalCheckFailed) {
			return addErr(gerr.NodesAttached)
		}
		return addErr(err)

	}
	fmt.Println("Edge does NOT exit....")
	//
	// log Event
	//
	// going straight to db is safe provided its part of a FetchNode lock and all updates to the "R" predicate are performed within the FetchNode lock.
	ev := event.AttachNode{CID: cUID, PID: pUID, SK: sortK}
	eID, err = eventNew(ev)
	if err != nil {
		return addErr(err)
	}
	//
	wg.Add(1)
	//
	go func() {
		defer wg.Done()
		//
		// Grab child scalar data and lock child  node. Unlocked in UnmarshalCache and defer. ALL SCALARS SHOUD BEGIN WITH sortk "A#"
		//
		cnd, err := gc.FetchForUpdate(cUID)
		defer cnd.Unlock("ON cUID for AttachNode second goroutine..")
		if err != nil {
			errch <- fmt.Errorf("AttachNode: error fetching child scalar data: %w", err)
			return
		}

		if ctyName, ok = cnd.GetType(); !ok {
			errch <- cache.NoNodeTypeDefinedErr
			return
		}
		var cty blk.TyAttrBlock // note: this will load cache.TyAttrC -> map[Ty_Attr]blk.TyAttrD
		if cty, err = cache.FetchType(ctyName); err != nil {
			errch <- err
			return
		}
		//
		// build NVclient based on Type info - contains all scalar types
		//
		var cnv ds.ClientNV
		for _, v := range cty {
			switch v.DT {
			// scalar types to be propagated
			case "I", "F", "Bl", "S": //TODO: these attributes should belong to pUpred type only. Can a node be made up of more than one type? Pesuming at this stage only 1, so all scalars are relevant.
				if v.Pg {
					// scalar type has propagation enabled
					fmt.Println("v.Name, V.DT=  Pg ", v.Name, v.DT, v.Pg)
					nv := &ds.NV{Name: v.Name}
					cnv = append(cnv, nv)
				}
			}
		}
		//
		// copy cache data into cnv and unlock child node. Note read lock is removed in UmarshalGQLMap
		//
		err = cnd.UnmarshalCache(cnv)
		if err != nil {
			errch <- fmt.Errorf("AttachNode: Unmarshal error : %s", err)
			return
		}
		//
		// **** wait for target UID *******
		//
		var target ovflTarget
		if target, ok = <-xch; !ok {
			errch <- fmt.Errorf("AttachNode: Channel xch prematurely closed and drained")
			return
		}
		fmt.Printf("t\narget from channel: %#v\n\n", target)
		tUID := target.tUID
		id := target.itemId
		if tUID == nil {
			errch <- fmt.Errorf("AttachNode: Got a target UID of nil")
			return
		}
		//
		// ConfigureUpred() has primed the target propagation block with cUID and XF Inuse flag. Ready for propagation of Scalar data.
		// lock pUID if it is the target of the data propagation.
		// for overflow blocks the entry in the Nd of the uid-pred is set to InUse which syncs access.
		var puidLocked bool
		if bytes.Equal(tUID, pUID) {
			puidLocked = true
			pnd, err = gc.FetchForUpdate(pUID, sortK)
			if err != nil {
				pnd.Unlock()
				errch <- err
				return
			}
		}
		for _, t := range cty {
			for _, v := range cnv {

				if t.Name == v.Name { //&& v.Value != nil {

					id, err = db.PropagateChildData(t, pUID, sortK, tUID, id, v.Value)
					if err != nil {
						if puidLocked {
							pnd.Unlock("Set parent lock in propgatechilddata...")
						}
						errch <- fmt.Errorf("AttachNode: error in PropagateChildData %w", err) //TODO: understand goroutine errch <- ??
						//gc.UnlockNode(tUID)
						return // triggers wg.Done()
					}
					break
				}
			}
		}

		if puidLocked {
			pnd.Unlock("Set parent lock in propgatechilddata...2")
		}
		//gc.UnlockNode(tUID)

		// append parent UID, targetUID to child R attribute
		// use cache to synchronise access to R predicate.
		// cnd, err = gc.FetchForUpdate(cUID) //TODO:  Lock but done' cache as I don't update cache before db update. Soln: don't use "R" which will load R item. Don't specify a sortk.
		// defer cnd.Unlock()
		// if err != nil {
		// 	errch <- fmt.Errorf("AttachNode: error fetching child scalar data: %w", err)
		// 	return
		// }
		// reverse edge is not cached so deal directly with database

		err = db.UpdateReverseEdge(cUID, pUID, tUID, sortK, id)
		if err != nil {
			errch <- err
			return
		}
		//
		// mark c-UID or overflow block if used, to Available (from in-iuse) in parent propagation block, then saves to db.
		//
		pnd, err = gc.FetchForUpdate(pUID, sortK)
		if err != nil {
			pnd.Unlock()
			errch <- err
			return
		}
		err = pnd.SetUpredAvailable(sortK, pUID, cUID, tUID, id)
		pnd.Unlock()
		if err != nil {
			errch <- err
		}

		// select {
		// 	case <-ctx.Done():

		// }
	}()
	//
	// fetch parent node to find its type. This will lock parent node for update (no shared locks). Explicit unlocked in defer
	//
	pnd, err = gc.FetchForUpdate(pUID, sortK)
	if err != nil {
		pnd.Unlock()
		return addErr(err)
	}
	// if ptyName, ok = pnd.GetType(); !ok {
	// 	return cache.NoNodeTypeDefinedErr
	// }
	// fmt.Println(ptyName)
	//
	// Configure parent uid-predicate block (basis of sortk value) used to determine target for propagating child scaling data.
	// This may involve creating overflow blocks. No child scalar data is propagated at this stage,
	// but child UID and/or XF flag are saved to the uid-pred block.
	//
	targetUID, id, err := pnd.ConfigureUpred(sortK, pUID, cUID)
	if err != nil {
		pnd.Unlock()
		err := fmt.Errorf("AttachNode: Error in configuring upd-pred block for propagation of child data: %w", err)
		// TODO: consider using a Cancel Context
		xch <- ovflTarget{}
		wg.Wait()
		<-errch
		return addErr(err)
	}
	pnd.Unlock("Unlock from main goroutine in AttachNode..")
	//
	// get concurrent goroutine to write event items
	//
	pass := ovflTarget{tUID: targetUID, itemId: id}
	xch <- pass

	wg.Wait()
	//
	// two goroutines can result in upto two errors
	//
	for i := 0; i < 2; i++ {
		select {
		case e := <-errch:

			if errors.Is(e, db.ErrItemSizeExceeded) {
				// Note: this error should note occur. I have changed from using the 400K dynamodb inbuilt item size limit to trigger a new
				// UID item for propagation to using the SIZE attribute limit as a conditional update.
				// recover from error and rerun operation
				e := recoverItemSizeErr(gc, pUID, cUID, targetUID, sortK)

				if len(e) > 0 {
					addErr(e...)
				} else {
					return AttachNode(cUID, pUID, sortK)
				}

			} else {
				addErr(e)
			}

		default:
		}
	}
	if len(errS) > 0 {
		return errS
	}
	return nil
}
