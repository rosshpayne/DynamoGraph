package cache

import (
	"fmt"
	"strings"

	blk "github.com/DynamoGraph/block"
	"github.com/DynamoGraph/db"
	"github.com/DynamoGraph/util"
)

func (g *GraphCache) LockNode(uid util.UID) {

	fmt.Printf("** Cache LockNode  Key Value: [%s]\n", uid.String())

	g.Lock()
	uids := uid.String()
	e := g.cache[uids]

	if e == nil {
		e = &entry{ready: make(chan struct{})}
		e.NodeCache = &NodeCache{}
		g.cache[uids] = e
		g.Unlock()
		close(e.ready)
	} else {
		g.Unlock()
		<-e.ready
	}
	//
	// lock e . Note: e can only be acquired from outside of this package via the Fetch* api.
	//
	e.Lock()

}

// UnlockNode used for blocks that are not cached.
func (e *entry) UnlockNode() error {

	fmt.Printf("** Cache UnlockNode  K\n")

	if e == nil {
		return fmt.Errorf("e is nil for ")
	}
	fmt.Println("Unlock e")
	if e.NodeCache == nil {
		fmt.Println("UnlockNode: for e.NodeCache == nul.......")
	}
	e.Unlock("from UnlockNode")
	fmt.Println("Unlocked e")

	return nil
}

func (g *GraphCache) FetchForUpdate(uid util.UID, sortk ...string) (*NodeCache, error) {
	var sortk_ string
	//	return g.FetchNode(uid, true)
	fmt.Printf("** Cache FetchForUpdate Cache Key Value: [%s]\n", uid.String())
	fmt.Println("FFU: acquire gLock")
	g.Lock()
	fmt.Println("FFU: acquired gLock")
	if len(sortk) > 0 {
		sortk_ = sortk[0]
	} else {
		sortk_ = "A#"
	}
	uids := uid.String()
	e := g.cache[uids]

	if e == nil {
		e = &entry{ready: make(chan struct{})}
		g.cache[uids] = e
		fmt.Println("FFU: release gLock")
		g.Unlock()
		fmt.Println("FFU: acquired gLock")
		// nb: type blk.NodeBlock []*DataItem
		nb, err := db.FetchNode(uid, sortk_)
		if err != nil {
			return nil, err
		}
		e.NodeCache = &NodeCache{m: make(map[SortKey]*blk.DataItem), gc: g}
		en := e.NodeCache
		en.Uid = uid
		for _, v := range nb {
			en.m[v.SortK] = v
		}
		close(e.ready)
	} else {
		fmt.Println("FFU: release gLock")
		g.Unlock()
		fmt.Println("FFU: released gLock")
		<-e.ready
	}
	//
	// lock e . Note: e can only be acquired from outside of this package via the Fetch* api.
	//
	fmt.Println("FFU: acquire eLock")
	e.Lock()
	fmt.Println("FFU: acquired eLock")
	//	if e != nil && e.NodeCache == nil || e == nil {
	if e.NodeCache == nil {
		e = nil
		// node cache has been cleared. Load again.
		g.FetchForUpdate(uid, sortk_)
	}
	e.ffuEnabled = true
	e.locked = false
	var found bool
	// check sortk is cached
	for k := range e.m {
		if strings.HasPrefix(k, sortk_) {
			found = true
			break
		}
	}
	if !found {
		e.fetchItems(sortk_) // e.NodeCache.fetchItems(sortk)
	}

	return e.NodeCache, nil
}

func (g *GraphCache) LockPredR(uid util.UID, sortk ...string) error {

	g.rsync.Lock()

	uids := uid.String()
	r := g.cacheR[uids]

	if r == nil {
		r = &Rentry{ready: make(chan struct{})}
		g.cacheR[uids] = r
		g.rsync.Unlock()
		close(r.ready)
	} else {
		g.rsync.Unlock()
		<-r.ready
	}

	r.Lock()

	return nil
}

func (g *GraphCache) FetchNode(uid util.UID, sortk ...string) (*NodeCache, error) {
	var sortk_ string
	fmt.Printf("** Cache FetchNode uid- %d %s sortK: %s \n\n", len(uid), uid.String(), sortk)

	g.Lock()
	if len(sortk) > 0 {
		sortk_ = sortk[0]
	} else {
		sortk_ = "A#"
	}
	uids := uid.String()
	e := g.cache[uids]

	if e == nil {
		e = &entry{ready: make(chan struct{})}
		g.cache[uids] = e
		g.Unlock()
		// nb: type blk.NodeBlock []*DataIte
		nb, err := db.FetchNode(uid, sortk_)
		if err != nil {
			return nil, err
		}
		e.NodeCache = &NodeCache{m: make(map[SortKey]*blk.DataItem), gc: g}
		en := e.NodeCache
		en.Uid = uid
		for _, v := range nb {
			en.m[v.SortK] = v
		}
		close(e.ready)
	} else {
		g.Unlock()
		<-e.ready
	}
	//
	// lock node cache.
	//
	e.RLock()
	// if e.NodeCache.m == nil {
	// 	// cache has been cleared. Start again.
	// 	e = nil
	// 	g.FetchNode(uid, sortk_)
	// }
	e.locked = true
	e.ffuEnabled = false
	var found bool
	// check sortk is cached. If not perform a db fetch using sortk.
	for k := range e.m {
		if strings.HasPrefix(k, sortk_) {
			found = true
			break
		}
	}
	if !found {
		e.fetchItems(sortk_) // TODO: error I think. What above if sortk has no prefix in key then this will loop forever.
	}

	return e.NodeCache, nil
}

func (g *NodeCache) fetchItems(sortk string) error {

	fmt.Printf("+++  Cache FetchItems for sortk %s UID: [%s] \n", sortk, g.Uid.String())

	nb, err := db.FetchNode(g.Uid, sortk)
	if err != nil {
		return err
	}
	// add data items to cache map
	for _, v := range nb {
		g.m[v.SortK] = v
	}

	return nil
}

// LockAndClearNodeCache - at times we only want to update the database directly to save having to update the cache as well.
// TO do this will lock the Node e entry in the cache (using the e.NodeCache Lock)  and nil the attached data mep.
// This will force the data to be loaded into the cache from the database when FetchNode/ForUpdate is next called.
func (g *GraphCache) LockAndClearNodeCache(uid util.UID) *entry {

	fmt.Println()
	fmt.Println("================================ LOCK and CLEAR NODE CACHE =======================================")
	fmt.Printf(" Clear node cache for: %s", uid.String())
	fmt.Println()
	//
	// check if node is cached
	//
	var (
		ok bool
		e  *entry
	)
	uids := uid.String()
	fmt.Println("Acquire gLock")
	g.Lock()
	fmt.Println("Acquired gLock")
	if e, ok = g.cache[uids]; !ok {
		//
		// create a no data cache node
		//
		e = &entry{ready: make(chan struct{})}
		e.NodeCache = &NodeCache{gc: g}
		g.cache[uids] = e
		g.Unlock()
		fmt.Println("REleased gLock")
		close(e.ready)

	} else {

		fmt.Println("RElease gLock")
		g.Unlock()
		fmt.Printf("REleased gLock e is %#v\n ", e)
		<-e.ready
	}
	//
	// lock node
	//
	fmt.Println("Acquire eLock")
	e.Lock()
	fmt.Println("Acquired eLock")
	//
	// clear the cache map (but not "e" at this point) as we need e for Lock/Unlock methods. e is cleared in FetchNode/FetchNodeForUpdate
	//
	e.NodeCache.m = nil

	fmt.Printf("== EXIT LOCK and CLEAR NODE CACHE == %#v\n", e)
	return e
}

// ClearNodeCache - clear the cache m map to force a reload on net FetchNode/ForUpdate.
func (g *GraphCache) ClearNodeCache(uid util.UID) error {

	fmt.Println()
	fmt.Println("================================ CLEAR NODE CACHE =======================================")
	fmt.Printf(" Clear node cache for: %s", uid.String())
	fmt.Println()
	//
	// check if node is cached
	//
	var (
		ty  string
		tab blk.TyAttrBlock
		ok  bool
	)
	g.Lock()
	if _, ok := g.cache[uid.String()]; !ok {
		fmt.Println("Nothing to clear")
		g.Unlock()
		return nil
	}
	g.Unlock()
	//
	// lock node
	//
	nc, err := g.FetchForUpdate(uid)
	defer nc.Unlock()
	if err != nil {
		return err
	}
	//
	// remove any overflow blocks
	//
	// get type definition and list its uid-predicates (e.g. siblings, friends)
	if ty, ok = nc.GetType(); !ok {
		return NoNodeTypeDefinedErr
	}
	if tab, err = FetchType(ty); err != nil {
		return err
	}

	for _, c := range tab.GetUIDpredC() {
		sortk := "A#G#:" + c
		// get sortk's overflow Block UIDs if any
		for _, uid_ := range nc.GetOvflUIDs(sortk) {
			g.Lock()
			if _, ok = g.cache[uid_.String()]; ok {
				// delete map entry will mean e is unassigned and allow GC to purge e and associated node cache.
				delete(g.cache, uid_.String())
				g.Unlock()
			} else {
				g.Unlock()
			}
		}
	}
	//
	// clear map entry
	//
	e := g.cache[uid.String()]
	e.NodeCache.m = nil
	//	delete(g.cache, uid.String()) // must take out g.Lock()
	//g.cache[uid.String()] = nil
	//
	fmt.Println("==Clear cache finished ==")
	return nil
}

func (nd *NodeCache) Unlock(s ...string) {
	if len(s) > 0 {
		fmt.Println("******* IN UNLOCK NC ******************** ", s[0])
	} else {
		fmt.Println("******* IN UNLOCK NC ********************")
	}
	if nd == nil {
		fmt.Println("Unlock with nd == nil")
	}
	if len(nd.m) == 0 {
		// locked by LockNode() - without caching daa
		fmt.Println("Unlock with m empty")
		nd.RWMutex.Unlock()
		return
	}
	if nd.ffuEnabled {
		nd.RWMutex.Unlock()
		fmt.Println("RWMutex UNLOCK")
		nd.ffuEnabled = false
	} else {
		if nd.locked {
			fmt.Println("RWMutex RUnlock()")
			nd.RUnlock()
			nd.locked = false
		}
	}
}

// // ClearOverflowCache: remove overflow blocks from the cache
// func (g *GraphCache) ClearOverflowCache(uid util.UID) error {

// 	fmt.Println()
// 	fmt.Println("================================ CLEAR NODE CACHE =======================================")
// 	fmt.Printf(" Clear any Overflow caches for: %s", uid.String())
// 	fmt.Println()
// 	//
// 	// check if node is cached
// 	//
// 	var (
// 		ty  string
// 		tab blk.TyAttrBlock
// 		ok  bool
// 	)
// 	g.Lock()
// 	if _, ok := g.cache[uid.String()]; !ok {
// 		fmt.Println("Nothing to clear")
// 		g.Unlock()
// 		return nil
// 	}
// 	g.Unlock()
// 	//
// 	// lock node
// 	//
// 	nc, err := g.FetchForUpdate(uid)
// 	defer nc.Unlock()
// 	if err != nil {
// 		return err
// 	}
// 	//
// 	// remove any overflow blocks
// 	//
// 	// get type definition and list its uid-predicates (e.g. siblings, friends)
// 	if ty, ok = nc.GetType(); !ok {
// 		return NoNodeTypeDefinedErr
// 	}
// 	if tab, err = FetchType(ty); err != nil {
// 		return err
// 	}

// 	for _, c := range tab.GetUIDpredC() {
// 		sortk := "A#G#:" + c
// 		// get sortk's overflow Block UIDs if any
// 		for _, uid_ := range nc.GetOvflUIDs(sortk) {
// 			g.Lock()
// 			if _, ok = g.cache[uid_.String()]; ok {
// 				delete(g.cache, uid_.String())
// 				g.Unlock()
// 			} else {
// 				g.Unlock()
// 			}
// 		}
// 	}

// 	return nil
// }
